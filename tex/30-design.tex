\chapter{Проектирование}
\label{cha:design}

%В данном разделе реализуется новая всячина.

\section{Выбор фреймворка}

Разработанный модуль использует сервисы зарегистрированные в регистре сервисов фреймворка предоставленные модулями приведенными в приложение А рис.~\ref{fig:comps}, темным фоном выделен разработанный модуль.

Модуль Apache Sling Health Check Web Console Plugin ищет в регистре сервисов фреймворка, сервисы зарегистрированные по интерфейсу HealthCheck и удовлетворяющие введенным пользователем фильтрам. Поэтому разработанные проверки реализуют интерфейс HealthCheck и представляют из себя сервис-компоненты, рис.~\ref{fig:classDia}. Каждая проверка реализует метод "execute" возвращающий результат проверки в виде лога который записывается во время выполнения, листинг \ref{lst:simpleExecute}. Лог отображается в веб плагине, и на его основе выставляется статус проверки. Возможные статусы сообщений: "debug", "info", "warn" и "critical".

\begin{listing}[H]
\inputminted[linenos,frame=single]{java}{inc/src/simpleExecute}
\caption{Главный метод проверок} 
\label{lst:simpleExecute}
\end{listing}

Сервис-компоненты создаются при помощи аннотации @Component, объявляющей класс компонентом, и аннотации @Service указывающий сервис интерфейс реализуемый данным компонентом \cite{web:felixScr}. Для проверок задаются обязательные свойства с помощью аннотации @Property, листинг \ref{lst:scrComponent}.
\begin{itemize}
\item HealthCheck.NAME – Отображаемое имя проверки.
\item HealthCheck.TAGS – Тэги проверки.
\item HealthCheck.MBEAN\_NAME – Имя проверки в JMX.
\end{itemize}

\begin{listing}[H]
\inputminted[linenos,frame=single]{java}{inc/src/scrComponent}
\caption{Объявление сервис-компонента проверки} 
\label{lst:scrComponent}
\end{listing}

Конфигурация компонент задается так-же через аннотацию @Property указанную для полей класса, листинг \ref{lst:scrProperty}. 

\begin{listing}[H]
\inputminted[linenos,frame=single]{java}{inc/src/scrProperty}
\caption{Конфигурируемые параметры сервис-компонента} 
\label{lst:scrProperty}
\end{listing}

Как было описано выше, активация компонент происходит при доступе к ним, при этом вызывается метод помеченный аннотацией @Activate и выполняются действия необходимые для работы компонента, а именно извлекаются значения конфигурации с помощью метода ComponentContext.getProperties(), данный объект является уникальным для каждого сервис-компонента, листинг \ref{lst:scrActivate}. После использования компонента, вызывается метод помеченный аннотацией @Deactivate в котором выполняется высвобождение ресурсов.

\begin{listing}[H]
\inputminted[linenos,frame=single]{java}{inc/src/scrActivate}
\caption{Методы активации и деактивации сервис-компонента} 
\label{lst:scrActivate}
\end{listing}

Доступ к сервисам зарегистрированным в регистре сервисов осуществляется с помощью внедрения зависимостей, по средствам аннотации @Reference. Листинг \ref{lst:scrReference}.

%fontsize=\footnotesize
%\begin{mdframed}[frametitle={Конфигурация сервис-компонента}]
%	\inputminted[linenos,frame=single]{java}{inc/src/scrComponent}
	%\frametitle{Конфигурация сервис-компонента}
%	\label{lst:scrComponent}
%\end{mdframed}
\begin{listing}[H]
\inputminted[linenos,frame=single]{java}{inc/src/scrReference}
\caption{Доступ к сервисам} 
\label{lst:scrReference}
\end{listing}

\subsection{Исследование фреймворков с помощью которых можно реализовать модуль}
Объект ComponentContext помимо параметров конфигурации позволяет получить контекст модулей системы тем самым предоставляя список всех модулей системы. В регистре сервисов системы зарегистрирован сервис ServiceComponentRuntime предоставляющий доступ к сервис-компонентам зарегистрированным в системе. Данный сервис предоставляет список всех сервис-компонентов зарегистрированных в системе для конкретного модуля. Во время выполнения проверки происходит проверка активность всех сервис-компонентов, все компоненты должны быть включены и для включенных проверяется статус, который должен быть active, если они не указаны в конфигурации как не активные.

\subsection{Сравнительная таблица}
Табличка 1.1

\begin{table}[ht]
  \caption{Сравнение SAML \cite{web:wikiSaml} фреймворков}
  \begin{tabular}{|p{3cm}|p{47mm}|p{30mm}|p{35mm}|}
  \hline
  Название      
  & Поддержка 
  & Количество запросов на stackoverflow 
  & Примеры \\
  \hline
  OpenSAML 3  
  & Поддерживается, последняя версия: март 2017
  & 399
  & Есть примеры, книги \\
  \hline
  OneLogin       			   
  & Поддерживается, последняя версия: ноябрь 2018
  & 324
  & Есть примеры \\
  \hline
  Spring Security SAML                
  & Поддерживается, последняя версия: март 2019
  & боле 500
  & Есть примеры \\
  \hline
  Pac4j       			   
  & Поддерживается, последняя версия: февраль 2019
  & 16
  & Есть примеры \\
  \hline
  \end{tabular}
  \label{tab:tabular}
\end{table}	

\subsection{Подробно про каждый фреймворк}
раз

два

три

\subsection{Выявленные проблемы с интеграцией}
раз

два

\subsection{Заключение}
В итоге выбрал OpenSaml

\section{Проектные решения}
Для решения поставленной задачи было принято решение разработать AEM пакет содержащий OSGI модуль в котором будут сервис-компоненты реализующие интерфейс предоставляемый модулей Sling Health Check Core. Так-же пакет должен содержать конфигурационные файлы которые будут задавать начальную конфигурацию для экземпляров автора и публикации при установки в систему и создавать необходимые узлы в JCR хранилище.

Интеграцию с Nagios реализовывать с помощью использования плагина обрабатывающего JSON ответ и извлекающего из него данные проверки.

\section{Заключение}
Архитектура седлана - можно кодить.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "rpz"
%%% End:
